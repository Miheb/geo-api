/*
 * Semtech Localization Algorithms
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package main

import (
	"encoding/json"
	"fmt"
	"math"
	"time"

	"./swagger"
	// WARNING!
	// Change this to a fully-qualified import path
	// once you place this file into your project.
	// For example,
	//
	//    sw "github.com/myname/myrepo/go"
	//
	// sw "./go"
)

func isEqualLat(gw1, gw2 swagger.GatewayReceptionTdoa) bool {
	return gw1.AntennaLocation.Latitude == gw2.AntennaLocation.Latitude
}

func isEqualLong(gw1, gw2 swagger.GatewayReceptionTdoa) bool {
	return gw1.AntennaLocation.Longitude == gw2.AntennaLocation.Longitude
}

func isEqualPlace(gw1, gw2 swagger.GatewayReceptionTdoa) bool {
	return isEqualLat(gw1, gw2) && isEqualLong(gw1, gw2)
}

func inter3(g1, g2, g3 swagger.GatewayReceptionTdoa) swagger.LocationEstimate {

	CX2 := 2 * (g2.AntennaLocation.Latitude - g1.AntennaLocation.Latitude)
	CX3 := 2 * (g3.AntennaLocation.Latitude - g1.AntennaLocation.Latitude)
	CY2 := 2 * (g2.AntennaLocation.Longitude - g1.AntennaLocation.Longitude)
	CY3 := 2 * (g3.AntennaLocation.Longitude - g1.AntennaLocation.Longitude)
	CR2 := math.Pow(g1.Rssi, 2) - math.Pow(g2.Rssi, 2) + (math.Pow(g2.AntennaLocation.Latitude, 2) + math.Pow(g2.AntennaLocation.Longitude, 2)) - (math.Pow(g1.AntennaLocation.Latitude, 2) + math.Pow(g1.AntennaLocation.Longitude, 2))
	CR3 := math.Pow(g1.Rssi, 2) - math.Pow(g3.Rssi, 2) + (math.Pow(g3.AntennaLocation.Latitude, 2) + math.Pow(g3.AntennaLocation.Longitude, 2)) - (math.Pow(g1.AntennaLocation.Latitude, 2) + math.Pow(g1.AntennaLocation.Longitude, 2))

	var CX float64
	var CY float64

	if isEqualPlace(g1, g2) || isEqualPlace(g1, g3) {
		fmt.Println("The three gateways are not distinct")
		return swagger.LocationEstimate{0, 0, 0, 0}
	} else if isEqualLat(g1, g2) {
		// 1 et 2 même x
		CY = CR2 / CY2
		CX = (CR3 - CY*CY3) / CX3
	} else if isEqualLat(g1, g3) {
		// 1 et 3 même x
		CY = CR3 / CY3
		CX = (CR2 - CY*CY2) / CX2
	} else if isEqualLong(g1, g2) {
		// 1 et 2 même y
		CX = CR2 / CX2
		CY = (CR3 - CX*CX3) / CY3
	} else if isEqualLong(g1, g3) {
		// 1 et 3 même y
		CX = CR3 / CX3
		CY = (CR2 - CX*CX2) / CY2
	} else {
		CYnum := CR2 - CX2*CR3/CX3
		CYden := CY2 - CX2*CY3/CX3

		CY = CYnum / CYden
		CX = (CR3 - CY*CY3) / CX3
	}

	return swagger.LocationEstimate{CX, CY, 0, 0}
}

func sq(x float64) float64 {
	return math.Pow(x, 2)
}

func tdoa(g1, g2, g3 swagger.GatewayReceptionTdoa) swagger.LocationEstimate {

	v := 50.0

	cX1 := -2 * (g2.AntennaLocation.Latitude - g1.AntennaLocation.Latitude)
	cX2 := -2 * (g3.AntennaLocation.Latitude - g2.AntennaLocation.Latitude)
	cX3 := -2 * (g1.AntennaLocation.Latitude - g3.AntennaLocation.Latitude)
	cY1 := -2 * (g2.AntennaLocation.Longitude - g1.AntennaLocation.Longitude)
	cY2 := -2 * (g3.AntennaLocation.Longitude - g2.AntennaLocation.Longitude)
	cY3 := -2 * (g1.AntennaLocation.Longitude - g3.AntennaLocation.Longitude)
	cT1 := 2 * sq(v) * float64(g2.Toa-g1.Toa)
	cT2 := 2 * sq(v) * float64(g3.Toa-g2.Toa)
	cT3 := 2 * sq(v) * float64(g1.Toa-g3.Toa)
	cR1 := -sq(g2.AntennaLocation.Latitude) + sq(g1.AntennaLocation.Latitude) - sq(g2.AntennaLocation.Longitude) + sq(g1.AntennaLocation.Longitude) + sq(v)*(sq(float64(g2.Toa))-sq(float64(g1.Toa)))
	cR2 := -sq(g3.AntennaLocation.Latitude) + sq(g2.AntennaLocation.Latitude) - sq(g3.AntennaLocation.Longitude) + sq(g2.AntennaLocation.Longitude) + sq(v)*(sq(float64(g3.Toa))-sq(float64(g2.Toa)))
	cR3 := -sq(g1.AntennaLocation.Latitude) + sq(g3.AntennaLocation.Latitude) - sq(g1.AntennaLocation.Longitude) + sq(g3.AntennaLocation.Longitude) + sq(v)*(sq(float64(g1.Toa))-sq(float64(g3.Toa)))

	cXX1 := cX1 - cT1*cX2/cT2
	cXX2 := cX2 - cT2*cX3/cT3
	cYY1 := cY1 - cT1*cY2/cT2
	cYY2 := cY2 - cT2*cY3/cT3
	cRR1 := cR1 - cT1*cR2/cT2
	cRR2 := cR2 - cT2*cR3/cT3

	x := (cRR1 - cYY1*cRR2/cYY2) / (cXX1 - cYY1*cXX2/cYY2)
	y := (cRR2 - x*cXX2) / cYY2
	//	t := (cR3 - y*cY3 - x*cX3) / cT3

	return swagger.LocationEstimate{x, y, 0, 0}

}

func main() {

	tm := time.Unix(1518328047, 0)
	fmt.Println(tm)

	var json3Sat = []byte(`[
	{
		"gatewayId": "string",
    "antennaId": 0,
    "rssi": 2,
    "snr": 0,
    "toa": 0,
    "encryptedToa": "",
    "antennaLocation": {
      "latitude": 4,
      "longitude": 0,
      "altitude": 0
		}
	},
	{
		"gatewayId": "string",
    "antennaId": 0,
    "rssi": 2,
    "snr": 0,
    "toa": 0,
    "encryptedToa": "",
    "antennaLocation": {
      "latitude": 2,
      "longitude": 2,
      "altitude": 0
		}
	},{
		"gatewayId": "string",
    "antennaId": 0,
    "rssi": 2,
    "snr": 0,
    "toa": 0,
    "encryptedToa": "",
    "antennaLocation": {
      "latitude": 4,
      "longitude": 4,
      "altitude": 0
		}
	}
	]`)
	var sats []swagger.GatewayReceptionTdoa
	err := json.Unmarshal(json3Sat, &sats)
	if err != nil {
		fmt.Println("error:", err)
	}
	fmt.Printf("%v", sats)
	if len(sats) < 3 {
		fmt.Println("error: you should provide at least 3 gateway data")
	} else {
		fmt.Println(inter3(sats[0], sats[1], sats[2]))
	}

}

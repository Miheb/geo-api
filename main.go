/*
 * Semtech Localization Algorithms
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package main

import (
	"encoding/json"
	"fmt"
	"math"

	"./swagger"
	// WARNING!
	// Change this to a fully-qualified import path
	// once you place this file into your project.
	// For example,
	//
	//    sw "github.com/myname/myrepo/go"
	//
	// sw "./go"
)

func isEqualLat(gw1, gw2 swagger.GatewayReceptionTdoa) bool {
	return gw1.AntennaLocation.Latitude == gw2.AntennaLocation.Latitude
}

func isEqualLong(gw1, gw2 swagger.GatewayReceptionTdoa) bool {
	return gw1.AntennaLocation.Longitude == gw2.AntennaLocation.Longitude
}

func isEqualPlace(gw1, gw2 swagger.GatewayReceptionTdoa) bool {
	return isEqualLat(gw1, gw2) && isEqualLong(gw1, gw2)
}

func inter3(g1, g2, g3 swagger.GatewayReceptionTdoa) swagger.LocationEstimate {

	CX2 := 2 * (g2.AntennaLocation.Latitude - g1.AntennaLocation.Latitude)
	CX3 := 2 * (g3.AntennaLocation.Latitude - g1.AntennaLocation.Latitude)
	CY2 := 2 * (g2.AntennaLocation.Longitude - g1.AntennaLocation.Longitude)
	CY3 := 2 * (g3.AntennaLocation.Longitude - g1.AntennaLocation.Longitude)
	CR2 := math.Pow(g1.Rssi, 2) - math.Pow(g2.Rssi, 2) + (math.Pow(g2.AntennaLocation.Latitude, 2) + math.Pow(g2.AntennaLocation.Longitude, 2)) - (math.Pow(g1.AntennaLocation.Latitude, 2) + math.Pow(g1.AntennaLocation.Longitude, 2))
	CR3 := math.Pow(g1.Rssi, 2) - math.Pow(g3.Rssi, 2) + (math.Pow(g3.AntennaLocation.Latitude, 2) + math.Pow(g3.AntennaLocation.Longitude, 2)) - (math.Pow(g1.AntennaLocation.Latitude, 2) + math.Pow(g1.AntennaLocation.Longitude, 2))

	var CX float64
	var CY float64

	if isEqualPlace(g1, g2) || isEqualPlace(g1, g3) {
		fmt.Println("The three gateways are not distinct")
		return swagger.LocationEstimate{0, 0, 0, 0}
	} else if isEqualLat(g1, g2) {
		// 1 et 2 même x
		CY = CR2 / CY2
		CX = (CR3 - CY*CY3) / CX3
	} else if isEqualLat(g1, g3) {
		// 1 et 3 même x
		CY = CR3 / CY3
		CX = (CR2 - CY*CY2) / CX2
	} else if isEqualLong(g1, g2) {
		// 1 et 2 même y
		CX = CR2 / CX2
		CY = (CR3 - CX*CX3) / CY3
	} else if isEqualLong(g1, g3) {
		// 1 et 3 même y
		CX = CR3 / CX3
		CY = (CR2 - CX*CX2) / CY2
	} else {
		CYnum := CR2 - CX2*CR3/CX3
		CYden := CY2 - CX2*CY3/CX3

		CY = CYnum / CYden
		CX = (CR3 - CY*CY3) / CX3
	}

	return swagger.LocationEstimate{CX, CY, 0, 0}
}

func sq(x float64) float64 {
	return math.Pow(x, 2)
}

func toa(g1, g2, g3 swagger.GatewayReceptionTdoa) swagger.LocationEstimate {

	v := 1.0

	cX1 := -2 * (g2.AntennaLocation.Latitude - g1.AntennaLocation.Latitude)
	cX2 := -2 * (g3.AntennaLocation.Latitude - g2.AntennaLocation.Latitude)
	cX3 := -2 * (g1.AntennaLocation.Latitude - g3.AntennaLocation.Latitude)
	cY1 := -2 * (g2.AntennaLocation.Longitude - g1.AntennaLocation.Longitude)
	cY2 := -2 * (g3.AntennaLocation.Longitude - g2.AntennaLocation.Longitude)
	cY3 := -2 * (g1.AntennaLocation.Longitude - g3.AntennaLocation.Longitude)
	cT1 := 2 * sq(v) * float64(g2.Toa-g1.Toa)
	cT2 := 2 * sq(v) * float64(g3.Toa-g2.Toa)
	cT3 := 2 * sq(v) * float64(g1.Toa-g3.Toa)
	cR1 := -sq(g2.AntennaLocation.Latitude) + sq(g1.AntennaLocation.Latitude) - sq(g2.AntennaLocation.Longitude) + sq(g1.AntennaLocation.Longitude) + sq(v)*(sq(float64(g2.Toa))-sq(float64(g1.Toa)))
	cR2 := -sq(g3.AntennaLocation.Latitude) + sq(g2.AntennaLocation.Latitude) - sq(g3.AntennaLocation.Longitude) + sq(g2.AntennaLocation.Longitude) + sq(v)*(sq(float64(g3.Toa))-sq(float64(g2.Toa)))
	cR3 := -sq(g1.AntennaLocation.Latitude) + sq(g3.AntennaLocation.Latitude) - sq(g1.AntennaLocation.Longitude) + sq(g3.AntennaLocation.Longitude) + sq(v)*(sq(float64(g1.Toa))-sq(float64(g3.Toa)))

	cXX1 := cX1 - cT1*cX2/cT2
	cXX2 := cX2 - cT2*cX3/cT3
	cYY1 := cY1 - cT1*cY2/cT2
	cYY2 := cY2 - cT2*cY3/cT3
	cRR1 := cR1 - cT1*cR2/cT2
	cRR2 := cR2 - cT2*cR3/cT3

	x := (cRR1 - cYY1*cRR2/cYY2) / (cXX1 - cYY1*cXX2/cYY2)
	y := (cRR2 - x*cXX2) / cYY2
	//	t := (cR3 - y*cY3 - x*cX3) / cT3

	return swagger.LocationEstimate{x, y, 0, 0}

}

func tdoa(g1, g2, g3, g4 swagger.GatewayReceptionTdoa) swagger.LocationEstimate {

	const c = 0.000299792458 // Speed of light in km/ns

	// Coordinates of gateways
	x1 := g1.AntennaLocation.Longitude
	y1 := g1.AntennaLocation.Latitude

	x2 := g2.AntennaLocation.Longitude
	y2 := g2.AntennaLocation.Latitude

	x3 := g3.AntennaLocation.Longitude
	y3 := g3.AntennaLocation.Latitude

	x4 := g4.AntennaLocation.Longitude
	y4 := g4.AntennaLocation.Latitude

	// Distances
	dr2 := c * float64(g2.Toa-g1.Toa)
	dr3 := c * float64(g3.Toa-g1.Toa)
	dr4 := c * float64(g4.Toa-g1.Toa)

	/*
		Substraction of circle equations to have linear equations,
		e1 : c2 - c1, e2 : c3 - c1, e3: c4 - c1
	*/

	/* Coefficients of equations with:
	ei: x*Xi + y*Yi + r*Ri = Ci */
	X1 := 2. * (x1 - x2)
	Y1 := 2. * (y1 - y2)
	R1 := -2. * dr2
	C1 := sq(dr2) - sq(x2) - sq(y2) + sq(x1) + sq(y1)

	X2 := 2. * (x1 - x3)
	Y2 := 2. * (y1 - y3)
	R2 := -2. * dr3
	C2 := sq(dr3) - sq(x3) - sq(y3) + sq(x1) + sq(y1)

	X3 := 2. * (x1 - x4)
	Y3 := 2. * (y1 - y4)
	R3 := -2. * dr4
	C3 := sq(dr4) - sq(x4) - sq(y4) + sq(x1) + sq(y1)

	/* Second rank coefficients with:
	e1: x*CX1 + y*CY1 = CC1
	e2: x*CX2 + y*CY2 = CC2
	e3: x*X3 + y*Y3 + r*R3 = C3
	*/
	CX1 := X1 - X3*R1/R3
	CX2 := X2 - X3*R2/R3

	CY1 := Y1 - Y3*R1/R3
	CY2 := Y2 - Y3*R2/R3

	CC1 := C1 - C3*R1/R3
	CC2 := C2 - C3*R2/R3

	/* Third rank coefficients with:
	e1: x*TX1 = TC1
	e2: x*CX2 + y*CY2 = CC2
	e3: x*X3 + y*Y3 + r*R3 = C3
	*/
	TX1 := CX1 - CX2*CY1/CY2
	TC1 := CC1 - CC2*CY1/CY2

	// Final coordinates

	X := TC1 / TX1
	Y := (CC2 - X*CX2) / CY2

	return swagger.LocationEstimate{X, Y, 0, 0}
}

func main() {
	//tm := time.Unix(1518328047, 0)
	//fmt.Println(tm)

	var json3Sat = []byte(`[
	{
		"gatewayId": "G1",
    "antennaId": 0,
    "rssi": 3.886,
    "snr": 0,
    "toa": 1033356,
    "encryptedToa": "",
    "antennaLocation": {
      "latitude": 8.0,
      "longitude": 6.0,
      "altitude": 0
		}
	},
	{
		"gatewayId": "G2",
    "antennaId": 0,
    "rssi": 4.24,
    "snr": 0,
    "toa": 1061506,
    "encryptedToa": "",
    "antennaLocation": {
      "latitude": -12.0,
      "longitude": 14.0,
      "altitude": 0
		}
	},{
		"gatewayId": "G3",
    "antennaId": 0,
    "rssi": 2.091,
    "snr": 0,
    "toa": 1048568,
    "encryptedToa": "",
    "antennaLocation": {
      "latitude": -4.0,
      "longitude": -14.0,
      "altitude": 0
		}
	},{
		"gatewayId": "G4",
    "antennaId": 0,
    "rssi": 2.091,
    "snr": 0,
    "toa": 1059670,
    "encryptedToa": "",
    "antennaLocation": {
      "latitude": 16.0,
      "longitude": -8.0,
      "altitude": 0
		}
	}
	]`)
	var sats []swagger.GatewayReceptionTdoa
	err := json.Unmarshal(json3Sat, &sats)
	if err != nil {
		fmt.Println("error:", err)
	}
	/*
		fmt.Printf("%v", sats)


			if len(sats) < 3 {
				fmt.Println("error: you should provide at least 3 gateway data")
			} else {
				fmt.Println(inter3(sats[0], sats[1], sats[2]))
			}
	*/

	fmt.Println(tdoa(sats[0], sats[1], sats[2], sats[3]))

}
